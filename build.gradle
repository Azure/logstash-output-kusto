import java.nio.file.Files
import java.nio.file.Paths

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING

apply plugin: 'java'
apply plugin: 'idea'
apply plugin: 'maven-publish'

// The gemspec contains the gem metadata to build and package the gem. The gradle build serves as a mechanism of getting these "vendor" files required for the gem.
// The alternative is to use ruby-maven gem to package, but this runs into classpath conflicts/issues with the logstash plugin.
group "org.logstash.outputs"

ext {
    jacksonVersion = '2.19.0'
    jnaVersion = '5.13.0'
    kustoVersion = '7.0.4'
    minidevVersion = '2.5.2'
    nettyVersion = '4.1.125.Final'
    resilience4jVersion = '1.7.1'
    reactorNettyVersion = '1.2.9'
    slf4jVersion = '2.0.17'
    tcnativeVersion = '2.0.72.Final'
    vavrVersion = '0.10.4'
}

def versionFile = Paths.get("version")
if (Files.exists(versionFile)) {
    version = Files.readAllLines(versionFile).first()
} else {
    version = "2.1.2"
}

repositories {
    mavenCentral()
}

// These dependencies are required by the gemspec to build the gem. The easiest to arrive at this list is to look at the effective pom of kusto-ingest and arrive at this list
// even if we use the ruby-maven gem to package the gem, install and lock_jars will create the logstash_output_kusto_jars.rb file with the same list of dependencies.
// In the gradle way, running ./gradlew vendor creates the jar file list and adds them to vendor/jar-dependencies folder from where it is referenced in the gemspec (require_paths and files)

// update dependencies to bom azure-sdk-bom/1.2.37 

dependencies {
    // Kusto client libraries (updated)
    implementation "com.microsoft.azure.kusto:kusto-data:${kustoVersion}"
    implementation "com.microsoft.azure.kusto:kusto-ingest:${kustoVersion}"

    // Azure client libraries (versions will be resolved by the BOM)
    implementation 'com.azure:azure-core-http-netty:1.16.0'
    implementation 'com.azure:azure-core:1.56.0'
    implementation 'com.azure:azure-data-tables:12.5.4'
    implementation 'com.azure:azure-identity:1.16.2'
    implementation 'com.azure:azure-json:1.5.0'
    implementation 'com.azure:azure-storage-blob:12.28.0'
    implementation 'com.azure:azure-storage-common:12.27.0'
    implementation 'com.azure:azure-storage-queue:12.23.0'
    implementation 'com.azure:azure-xml:1.2.0'

    // Jackson - bump to a newer 2.19.x patch
    implementation "com.fasterxml.jackson.core:jackson-annotations:${jacksonVersion}"
    implementation "com.fasterxml.jackson.core:jackson-core:${jacksonVersion}"
    implementation "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
    implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jacksonVersion}"

    implementation 'com.fasterxml.woodstox:woodstox-core:7.1.0'
    implementation 'com.github.stephenc.jcip:jcip-annotations:1.0-1'
    // MSAL4J bump
    implementation 'com.microsoft.azure:msal4j:1.22.0'
    implementation 'com.nimbusds:content-type:2.3'
    implementation 'com.nimbusds:lang-tag:1.7'
    implementation 'com.nimbusds:nimbus-jose-jwt:10.4.2'
    implementation 'com.nimbusds:oauth2-oidc-sdk:11.27'
    implementation 'com.univocity:univocity-parsers:2.9.1'
    implementation 'commons-codec:commons-codec:1.19.0'
    implementation 'commons-logging:commons-logging:1.3.1'
    implementation "io.github.resilience4j:resilience4j-core:${resilience4jVersion}"
    implementation "io.github.resilience4j:resilience4j-retry:${resilience4jVersion}"
    implementation "io.netty:netty-buffer:${nettyVersion}"
    implementation "io.netty:netty-codec-dns:${nettyVersion}"
    implementation "io.netty:netty-codec-http2:${nettyVersion}"
    implementation "io.netty:netty-codec-http:${nettyVersion}"
    implementation "io.netty:netty-codec-socks:${nettyVersion}"
    implementation "io.netty:netty-codec:${nettyVersion}"
    implementation "io.netty:netty-common:${nettyVersion}"
    implementation "io.netty:netty-handler-proxy:${nettyVersion}"
    implementation "io.netty:netty-handler:${nettyVersion}"
    implementation "io.netty:netty-resolver-dns-classes-macos:${nettyVersion}"
    implementation "io.netty:netty-resolver-dns-native-macos:${nettyVersion}:osx-x86_64"
    implementation "io.netty:netty-resolver-dns:${nettyVersion}"
    implementation "io.netty:netty-resolver:${nettyVersion}"
    implementation "io.netty:netty-tcnative-boringssl-static:${tcnativeVersion}"
    implementation "io.netty:netty-tcnative-classes:${tcnativeVersion}"
    implementation "io.netty:netty-transport-classes-epoll:${nettyVersion}"
    implementation "io.netty:netty-transport-classes-kqueue:${nettyVersion}"
    implementation "io.netty:netty-transport-native-epoll:${nettyVersion}:linux-x86_64"
    implementation "io.netty:netty-transport-native-kqueue:${nettyVersion}:osx-x86_64"
    implementation "io.netty:netty-transport-native-unix-common:${nettyVersion}"
    implementation "io.netty:netty-transport:${nettyVersion}"
    implementation "io.projectreactor.netty:reactor-netty-core:${reactorNettyVersion}"
    implementation "io.projectreactor.netty:reactor-netty-http:${reactorNettyVersion}"
    implementation "io.projectreactor:reactor-core:3.7.9"
    implementation "io.vavr:vavr:${vavrVersion}"
    implementation "io.vavr:vavr-match:${vavrVersion}"
    implementation "net.java.dev.jna:jna-platform:${jnaVersion}"
    implementation "net.java.dev.jna:jna:${jnaVersion}"
    implementation "net.minidev:accessors-smart:${minidevVersion}"
    implementation "net.minidev:json-smart:${minidevVersion}"
    implementation 'org.apache.commons:commons-text:1.11.0'
    implementation 'org.apache.httpcomponents:httpclient:4.5.14'
    implementation 'org.apache.httpcomponents:httpcore:4.4.16'
    implementation 'org.codehaus.woodstox:stax2-api:4.2.2'
    implementation 'org.jetbrains:annotations:24.1.0'
    implementation 'org.ow2.asm:asm:9.7'
    implementation 'org.reactivestreams:reactive-streams:1.0.4'
    implementation "org.slf4j:slf4j-api:${slf4jVersion}"
    implementation "org.slf4j:slf4j-simple:${slf4jVersion}"
}

// This task generates the ruby file with all the dependencies. Once this task runs, look at the lib/logstash-output-kusto_jars.rb file
// that references all the dependent jar files. (the wrapper is the ./gradle vendor task)
task generateGemJarRequiresFile {
    doLast {
        File jars_file = file('lib/logstash-output-kusto_jars.rb')
        jars_file.newWriter().withWriter { w ->
            w << "# AUTOGENERATED BY THE GRADLE SCRIPT. DO NOT EDIT.\n\n"
            w << "require 'jar_dependencies'\n"
            configurations.runtimeClasspath.allDependencies.each { dep ->
                w << "require_jar('${dep.group}', '${dep.name}', '${dep.version}')\n"
            }
        }
    }
}

// The vendor task copies the jars from the runtimeClasspath to the vendor/jar-dependencies folder.
// This is referenced in the gemspec as the require_paths and files. Once this vendor task runs, look at the lib/logstash-output-kusto_jars.rb file
// that references all the dependent jar files.
task vendor {
    // take in all the dependencies from the runtimeClasspath and copy them to the vendor/jar-dependencies folder
    doLast {
        String vendorPathPrefix = "vendor/jar-dependencies"
        configurations.runtimeClasspath.allDependencies.each { dep ->
            println("Copying ${dep.group}:${dep.name}:${dep.version}")
            File f = configurations.runtimeClasspath.filter { it.absolutePath.contains("${dep.group}${File.separator}${dep.name}${File.separator}${dep.version}") }.singleFile
            String groupPath = dep.group.replaceAll('\\.', '/')
            File newJarFile = file("${vendorPathPrefix}${File.separator}${groupPath}${File.separator}${dep.name}${File.separator}${dep.version}${File.separator}${dep.name}-${dep.version}.jar")
            newJarFile.mkdirs()
            Files.copy(f.toPath(), newJarFile.toPath(), REPLACE_EXISTING)
        }
        String projectGroupPath = project.group.replaceAll('\\.', '/')
        File projectJarFile = file("${vendorPathPrefix}${File.separator}${projectGroupPath}${File.separator}${project.name}${File.separator}${project.version}${File.separator}${project.name}-${project.version}.jar")
        projectJarFile.mkdirs()
        Files.copy(file("$buildDir${File.separator}libs${File.separator}${project.name}-${project.version}.jar").toPath(), projectJarFile.toPath(), REPLACE_EXISTING)
    }
}

// The jar task is the standard packaging task & the generateGemJarRequiresFile task generates the ruby file with all the dependencies.
vendor.dependsOn(jar, generateGemJarRequiresFile)